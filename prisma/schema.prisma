// prisma/schema.prisma
// ETICA - Schéma aligné sur la méthodologie (12 domaines, dépendances, maturité)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTIFICATION (garder l'existant)
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  password      String?
  image         String?
  role          UserRole  @default(VIEWER)

  ownedSias       Sia[]
  memberships     SiaMember[]
  assignedActions Action[]
  arbitrations    Arbitration[]

  accounts      Account[]
  sessions      Session[]

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  ADMIN
  OWNER
  CONTRIBUTOR
  REVIEWER
  VIEWER
}

// ============================================
// SIA - Système d'Intelligence Artificielle
// ============================================

model Sia {
  id          String    @id @default(cuid())

  // Identité
  name        String
  description String?   @db.Text
  sector      Sector
  status      SiaStatus @default(DRAFT)

  // NOUVEAU : Finalité ultime (critique pour détecter les dilemmes)
  finalPurpose    String?   @db.Text  // Ex: "Trier automatiquement les CV"

  // Contexte d'usage (NOUVEAU)
  usageFrequency  Frequency @default(ON_DEMAND)
  userScale       Scale     @default(SMALL)
  geographicScope String[]  // Pays/régions concernés

  // Cadrage existant
  decisionType    DecisionType
  populations     String[]
  hasVulnerable   Boolean   @default(false)

  // Parties prenantes (NOUVEAU)
  stakeholders    Json?     // [{role, impact, powerLevel}]

  // Scénarios de mésusage (NOUVEAU)
  misuseScenarios String[]

  // Dépendances externes (pré-identifiées au wizard)
  hasExternalAI     Boolean   @default(false)
  hasExternalInfra  Boolean   @default(false)
  externalProviders String[]

  // Propriétaire
  ownerId     String
  owner       User      @relation(fields: [ownerId], references: [id])

  // Relations
  members     SiaMember[]
  nodes       Node[]
  edges       Edge[]
  dilemmas    Dilemma[]
  actions     Action[]
  versions    Version[]

  // Dates
  nextReviewDate DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([ownerId])
}

model SiaMember {
  id     String   @id @default(cuid())
  siaId  String
  sia    Sia      @relation(fields: [siaId], references: [id], onDelete: Cascade)
  userId String
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   UserRole @default(VIEWER)

  createdAt DateTime @default(now())

  @@unique([siaId, userId])
}

// Secteur d'activité (pour règles contextuelles)
enum Sector {
  HEALTH
  FINANCE
  HR
  COMMERCE
  JUSTICE
  ADMINISTRATION
  EDUCATION
  TRANSPORT
  INSURANCE
  OTHER
}

enum SiaStatus {
  DRAFT
  ACTIVE
  REVIEW
  ARCHIVED
}

enum DecisionType {
  INFORMATIVE
  RECOMMENDATION
  ASSISTED_DECISION
  AUTO_DECISION
}

enum Scale {
  TINY        // < 100
  SMALL       // 100 - 10K
  MEDIUM      // 10K - 100K
  LARGE       // 100K - 1M
  VERY_LARGE  // > 1M
}

enum Frequency {
  REALTIME
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  ON_DEMAND
  ONE_TIME
}

// ============================================
// LES 12 DOMAINES ÉTHIQUES
// ============================================

enum EthicalDomain {
  // Cercle 1 : Les Personnes (6)
  PRIVACY           // Vie privée
  EQUITY            // Équité
  TRANSPARENCY      // Transparence
  AUTONOMY          // Autonomie
  SECURITY          // Sécurité
  RECOURSE          // Recours

  // Cercle 2 : L'Organisation (3)
  MASTERY           // Maîtrise
  RESPONSIBILITY    // Responsabilité
  SOVEREIGNTY       // Souveraineté

  // Cercle 3 : La Société (3)
  SUSTAINABILITY    // Durabilité
  LOYALTY           // Loyauté
  SOCIETAL_BALANCE  // Équilibre sociétal
}

// ============================================
// NOEUDS (Blocs du graphe)
// ============================================
// IMPORTANT : Les données ne sont PAS dans les nœuds, uniquement dans les flux

model Node {
  id     String   @id @default(cuid())
  siaId  String
  sia    Sia      @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Identité
  type    NodeType
  subtype String?
  label   String

  // Position React Flow
  positionX  Float  @default(0)
  positionY  Float  @default(0)

  // Annotation des domaines (aide le moteur de détection)
  reinforcesDomains EthicalDomain[]  // Ce bloc renforce ces domaines
  affectsDomains    EthicalDomain[]  // Ce bloc peut affecter ces domaines

  // Attributs spécifiques au type (JSON flexible)
  // Voir documentation ci-dessous
  attributes Json @default("{}")

  // Relations
  outgoingEdges Edge[] @relation("EdgeSource")
  incomingEdges Edge[] @relation("EdgeTarget")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
}

// DOCUMENTATION DES ATTRIBUTS PAR TYPE DE NŒUD :
//
// Pour HUMAN:
// {
//   humanType: "user" | "operator" | "supervisor" | "affected_third_party",
//   vulnerability: "none" | "minor" | "significant" | "high",
//   expertise: "low" | "medium" | "high",
//   hasConsented: boolean,
//   canAppeal: boolean,
//   decisionPower: "none" | "advisory" | "blocking" | "final"
// }
//
// Pour AI:
// {
//   modelType: "rules" | "ml_classic" | "deep_learning" | "llm",
//   autonomyLevel: "informative" | "suggestive" | "decisive" | "autonomous",
//   hasExplainability: boolean,
//   hasBiasTesting: boolean,
//
//   // ATTRIBUTS DE DÉPENDANCE (si externe)
//   isExternal: boolean,
//   provider: string | null,           // "OpenAI", "Anthropic", "Google", "Microsoft"
//   modelName: string | null,          // "GPT-4", "Claude 3.5"
//   isOpaque: boolean,                 // Fonctionnement interne inconnu
//   canTrainOnYourData: boolean,       // Fournisseur utilise vos données
//   hasFallback: boolean,
//   fallbackDescription: string | null
// }
//
// Pour INFRA:
// {
//   infraType: "database" | "api" | "storage" | "interface" | "data_lake",
//   hasEncryption: boolean,
//   retentionPolicy: "minimal" | "standard" | "long" | "indefinite",
//
//   // ATTRIBUTS DE DÉPENDANCE (si externe)
//   isExternal: boolean,
//   provider: string | null,           // "AWS", "Azure", "GCP", "OVH"
//   location: "EU" | "US" | "OTHER" | "UNKNOWN",
//   hasFallback: boolean,
//   fallbackDescription: string | null,
//   slaLevel: string | null,           // "99.9%", "99%"
//   canModifyWithoutNotice: boolean
// }
//
// Pour ORG:
// {
//   orgType: "deployer" | "subcontractor" | "regulator" | "data_controller",
//   jurisdiction: string,
//   responsibilities: string[]
// }

enum NodeType {
  HUMAN
  AI
  INFRA
  ORG
}

// ============================================
// FLUX (Liens entre blocs)
// ============================================
// IMPORTANT : C'est ICI que sont définies les données transportées

model Edge {
  id       String @id @default(cuid())
  siaId    String
  sia      Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Connexion
  sourceId String
  source   Node   @relation("EdgeSource", fields: [sourceId], references: [id], onDelete: Cascade)
  targetId String
  target   Node   @relation("EdgeTarget", fields: [targetId], references: [id], onDelete: Cascade)

  // Nom du flux
  label    String?

  // Direction (qui initie)
  direction FlowDirection

  // Nature technique du flux
  nature    FlowNature

  // NOUVEAU : Intention du flux (pourquoi ce flux existe)
  intent    FlowIntent

  // NOUVEAU : Canal technique
  channel   FlowChannel @default(API)

  // === DONNÉES TRANSPORTÉES (unique endroit où c'est défini) ===
  dataCategories DataCategory[]
  sensitivity    Sensitivity     @default(STANDARD)

  // Niveau d'automatisation
  automation     AutomationLevel @default(INFORMATIVE)

  // NOUVEAU : Réversibilité de la décision
  isReversible   Boolean         @default(true)

  // Criticité du flux
  criticality    FlowCriticality @default(IMPORTANT)

  // Métadonnées
  frequency      Frequency       @default(ON_DEMAND)
  legalBasis     LegalBasis?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
  @@index([sourceId])
  @@index([targetId])
}

enum FlowDirection {
  H2M   // Humain vers Machine
  M2M   // Machine vers Machine
  M2H   // Machine vers Humain
  H2H   // Humain vers Humain (via machine)
}

enum FlowNature {
  COLLECT         // Collecte de données
  INFERENCE       // Traitement/inférence
  ENRICHMENT      // Enrichissement de données
  DECISION        // Prise de décision
  RECOMMENDATION  // Recommandation
  NOTIFICATION    // Notification/affichage
  LEARNING        // Apprentissage
  CONTROL         // Contrôle/supervision
  TRANSFER        // Transfert simple
  STORAGE         // Stockage
}

// NOUVEAU : Intention du flux
enum FlowIntent {
  COMMAND         // Ordre d'action
  FEEDBACK        // Retour/évaluation
  SURVEILLANCE    // Monitoring/contrôle
  INFORMATION     // Notification/affichage
  EVALUATION      // Scoring/classement
  TRAINING        // Données d'apprentissage
  QUERY           // Requête/interrogation
}

// NOUVEAU : Canal technique
enum FlowChannel {
  API             // Appel API
  USER_INTERFACE  // Interface utilisateur
  SENSOR          // Capteur/IoT
  NOTIFICATION    // Push/email/SMS
  BATCH_PROCESS   // Traitement batch
  WEBHOOK         // Webhook
  FILE_TRANSFER   // Transfert de fichier
}

enum DataCategory {
  IDENTIFIER        // Nom, email, téléphone
  DEMOGRAPHIC       // Âge, genre, nationalité
  LOCATION          // Adresse, GPS
  FINANCIAL         // Revenus, transactions
  HEALTH            // Données de santé
  BIOMETRIC         // Empreintes, visage
  BEHAVIORAL        // Historique, navigation
  PROFESSIONAL      // CV, performance
  OPINION           // Opinions politiques/religieuses
  JUDICIAL          // Casier, litiges
  INFERRED          // Données déduites
  CONTENT           // Contenu utilisateur
  TECHNICAL         // Logs, métadonnées
  OTHER
}

enum Sensitivity {
  STANDARD
  SENSITIVE          // Art. 9 RGPD
  HIGHLY_SENSITIVE   // Santé, biométrie, judiciaire
}

enum AutomationLevel {
  INFORMATIVE           // Information pure
  ASSISTED              // Aide à la décision
  SEMI_AUTO             // Décision avec validation humaine
  AUTO_WITH_RECOURSE    // Auto mais contestable
  AUTO_NO_RECOURSE      // Auto sans recours
}

enum FlowCriticality {
  ACCESSORY    // Le système peut fonctionner sans
  IMPORTANT    // Dégrade le service si absent
  CRITICAL     // Le système ne peut pas fonctionner sans
}

enum LegalBasis {
  CONSENT
  CONTRACT
  LEGAL_OBLIGATION
  VITAL_INTEREST
  PUBLIC_INTEREST
  LEGITIMATE_INTEREST
}

// ============================================
// DILEMMES ÉTHIQUES
// ============================================

model Dilemma {
  id     String @id @default(cuid())
  siaId  String
  sia    Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Format "Domaine A ↔ Domaine B"
  domainA EthicalDomain
  domainB EthicalDomain

  // Règle qui a déclenché ce dilemme
  ruleId     String       // Ex: "E-01", "S-03", "D-02"
  ruleName   String       // Ex: "API externe pour fonction critique"
  ruleFamily RuleFamily

  // Description générée
  formulation String @db.Text

  // NOUVEAU : Mécanisme qui rend le dilemme inévitable
  mechanism   String @db.Text

  // Traçabilité vers le graphe
  affectedNodeIds String[]
  affectedEdgeIds String[]

  // Qualification
  severity            Int      // 1-5
  aggravatingFactors  String[]
  mitigatingFactors   String[]

  // Aide à l'arbitrage
  questionsToConsider    String[]
  stakeholdersToConsult  String[]

  // NOUVEAU : Guidance (sans juger moralement)
  acceptablePatterns     String[]  // Ex: "trade-off explicite + seuils"
  requiredEvidences      String[]  // Ex: "Test de biais", "Procédure de recours"

  // Statut
  status DilemmaStatus @default(DETECTED)

  // Arbitrage
  arbitration Arbitration?

  // Actions liées
  actions Action[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
  @@index([ruleFamily])
  @@index([status])
}

enum RuleFamily {
  STRUCTURAL    // S - Analyse de la forme du graphe
  DATA          // D - Analyse des flux de données
  DEPENDENCY    // E - Analyse des composants externes
  CONTEXTUAL    // C - Selon le secteur d'application
  GOVERNANCE    // G - Organisation autour du système
}

enum DilemmaStatus {
  DETECTED
  VALIDATED
  CONTESTED
  ARBITRATED
  IN_PROGRESS
  RESOLVED
}

// ============================================
// ARBITRAGE (4 questions + score de maturité)
// ============================================

model Arbitration {
  id        String  @id @default(cuid())
  dilemmaId String  @unique
  dilemma   Dilemma @relation(fields: [dilemmaId], references: [id], onDelete: Cascade)

  // Question 1 : Quel pôle priorisez-vous ?
  prioritizedDomain EthicalDomain

  // Question 2 : Pourquoi cette priorisation ?
  justificationCategory JustificationCategory
  justificationText     String @db.Text

  // Question 3 : Comment limitez-vous les risques ?
  mitigationActions String[]

  // Question 4 : Quand réviser ?
  revisionTriggers  RevisionTrigger[]
  revisionDate      DateTime?
  revisionCondition String?

  // NOUVEAU : Score de maturité (0-4)
  maturityLevel ArbitrationMaturity @default(RECOGNIZED)

  // Documentation des désaccords
  hasDisagreement        Boolean              @default(false)
  divergentPositions     DivergentPosition[]
  finalDecisionAuthority String?

  // Métadonnées
  arbitratedById String?
  arbitratedBy   User?    @relation(fields: [arbitratedById], references: [id])
  arbitratedAt   DateTime @default(now())

  // Évidences fournies (pour niveau 3+)
  evidences Evidence[]

  // Actions générées
  actions Action[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// NOUVEAU : Score de maturité de l'arbitrage
enum ArbitrationMaturity {
  NOT_TREATED   // 0 - Dilemme non reconnu
  RECOGNIZED    // 1 - Reconnu mais options non analysées
  DECIDED       // 2 - Trade-off explicite mais sans preuves
  TESTED        // 3 - Preuves (tests, red-team, audits)
  MONITORED     // 4 - KPIs + alerting + recours + revue
}

enum JustificationCategory {
  REGULATORY_CONSTRAINT   // Une réglementation impose ce choix
  USER_EXPECTATIONS       // Les utilisateurs ont exprimé ce besoin
  ECONOMIC_CONSTRAINT     // Raisons budgétaires
  TECHNICAL_CONSTRAINT    // Limitations techniques
  STRATEGIC_CHOICE        // Décision stratégique délibérée
  OTHER
}

// NOUVEAU : Triggers de révision structurés
enum RevisionTrigger {
  DATA_SOURCE_CHANGE      // Changement de source de données
  MODEL_CHANGE            // Changement de modèle
  PROVIDER_CHANGE         // Changement de fournisseur
  NEW_USER_GROUP          // Nouveau groupe d'utilisateurs
  NEW_GEOGRAPHIC_SCOPE    // Nouveau périmètre géographique
  INCIDENT                // Incident survenu
  REGULATORY_CHANGE       // Changement réglementaire
  SCHEDULED_REVIEW        // Revue programmée
  DRIFT_DETECTED          // Dérive détectée
}

model DivergentPosition {
  id            String @id @default(cuid())
  arbitrationId String
  arbitration   Arbitration @relation(fields: [arbitrationId], references: [id], onDelete: Cascade)

  stakeholder String
  role        String
  position    String  @db.Text

  createdAt DateTime @default(now())
}

// ============================================
// ACTIONS
// ============================================

model Action {
  id    String @id @default(cuid())
  siaId String
  sia   Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Liens
  dilemmaId     String?
  dilemma       Dilemma?     @relation(fields: [dilemmaId], references: [id], onDelete: SetNull)
  arbitrationId String?
  arbitration   Arbitration? @relation(fields: [arbitrationId], references: [id], onDelete: SetNull)

  // Contenu
  title       String
  description String?  @db.Text

  // Type d'action selon la méthodologie
  actionType ActionType
  category   ActionCategory

  // Domaine cible
  targetDomain   EthicalDomain?
  expectedImpact Int?  // -2 à +2

  // Priorisation
  priority Priority @default(MEDIUM)
  effort   Effort   @default(MEDIUM)
  status   ActionStatus @default(TODO)

  // Dates
  dueDate     DateTime?
  completedAt DateTime?

  // Assignation
  assigneeId String?
  assignee   User?   @relation(fields: [assigneeId], references: [id])

  // Preuves
  evidences Evidence[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
  @@index([dilemmaId])
  @@index([status])
}

enum ActionType {
  MITIGATION    // Réduire l'intensité de la tension
  COMPENSATION  // Contrebalancer le pôle minoré
  SURVEILLANCE  // Monitorer l'évolution
}

enum ActionCategory {
  MINIMIZATION
  TRANSPARENCY
  HUMAN_CONTROL
  RECOURSE
  TECHNICAL
  ORGANIZATIONAL
  DESIGN
  CONTRACTUAL
  DOCUMENTATION
}

enum Priority {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum Effort {
  TRIVIAL
  SMALL
  MEDIUM
  LARGE
  HUGE
}

enum ActionStatus {
  TODO
  IN_PROGRESS
  BLOCKED
  DONE
  CANCELLED
}

// ============================================
// PREUVES (pour maturité niveau 3+)
// ============================================

model Evidence {
  id       String @id @default(cuid())

  // Peut être liée à une action OU un arbitrage
  actionId      String?
  action        Action?      @relation(fields: [actionId], references: [id], onDelete: Cascade)
  arbitrationId String?
  arbitration   Arbitration? @relation(fields: [arbitrationId], references: [id], onDelete: Cascade)

  type     EvidenceType
  title    String
  description String?
  url      String?
  fileKey  String?
  fileName String?

  uploadedAt DateTime @default(now())
}

enum EvidenceType {
  DOCUMENT
  SCREENSHOT
  LINK
  CODE
  TEST_RESULT
  AUDIT_REPORT
  METRIC_DASHBOARD
  PROCEDURE
  OTHER
}

// ============================================
// VERSIONING
// ============================================

model Version {
  id        String @id @default(cuid())
  siaId     String
  sia       Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  number    Int
  label     String?
  snapshot  Json
  changelog String?  @db.Text

  createdAt DateTime @default(now())

  @@unique([siaId, number])
  @@index([siaId])
}
