// prisma/schema.prisma
// ETICA - Schéma aligné sur la méthodologie (12 domaines, dépendances, maturité)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTIFICATION (garder l'existant)
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  password      String?
  image         String?
  role          UserRole  @default(VIEWER)

  ownedSias       Sia[]
  memberships     SiaMember[]
  assignedActions Action[]
  arbitrations    Arbitration[]

  accounts      Account[]
  sessions      Session[]

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  ADMIN
  OWNER
  CONTRIBUTOR
  REVIEWER
  VIEWER
}

// ============================================
// SIA - Système d'Intelligence Artificielle
// ============================================

model Sia {
  id          String    @id @default(cuid())

  // Identité
  name        String
  description String?   @db.Text
  sector      Sector
  status      SiaStatus @default(DRAFT)

  // NOUVEAU : Finalité ultime (critique pour détecter les dilemmes)
  finalPurpose    String?   @db.Text  // Ex: "Trier automatiquement les CV"

  // Contexte d'usage (NOUVEAU)
  usageFrequency  Frequency @default(ON_DEMAND)
  userScale       Scale     @default(SMALL)
  geographicScope String[]  // Pays/régions concernés

  // Cadrage existant
  decisionType    DecisionType @default(INFORMATIVE)
  dataTypes       String[]     // Types de données traitées
  populations     String[]
  hasVulnerable   Boolean   @default(false)

  // Scores de vigilance (calculés)
  vigilanceScores Json?

  // Parties prenantes (NOUVEAU)
  stakeholders    Json?     // [{role, impact, powerLevel}]

  // Scénarios de mésusage (NOUVEAU)
  misuseScenarios String[]

  // Dépendances externes (pré-identifiées au wizard)
  hasExternalAI     Boolean   @default(false)
  hasExternalInfra  Boolean   @default(false)
  externalProviders String[]

  // Propriétaire
  ownerId     String
  owner       User      @relation(fields: [ownerId], references: [id])

  // Relations
  members     SiaMember[]
  nodes       Node[]
  edges       Edge[]
  tensions    Tension[]
  actions     Action[]
  versions    Version[]

  // Dates
  nextReviewDate DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([ownerId])
}

model SiaMember {
  id     String   @id @default(cuid())
  siaId  String
  sia    Sia      @relation(fields: [siaId], references: [id], onDelete: Cascade)
  userId String
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   UserRole @default(VIEWER)

  createdAt DateTime @default(now())

  @@unique([siaId, userId])
}

// Secteur d'activité (pour règles contextuelles)
enum Sector {
  HEALTH
  FINANCE
  HR
  COMMERCE
  JUSTICE
  ADMINISTRATION
  EDUCATION
  TRANSPORT
  INSURANCE
  SECURITY
  MARKETING
  OTHER
}

enum SiaStatus {
  DRAFT
  ACTIVE
  REVIEW
  ARCHIVED
}

enum DecisionType {
  INFORMATIVE
  RECOMMENDATION
  ASSISTED_DECISION
  AUTO_DECISION
}

enum Scale {
  TINY        // < 100
  SMALL       // 100 - 10K
  MEDIUM      // 10K - 100K
  LARGE       // 100K - 1M
  VERY_LARGE  // > 1M
}

enum Frequency {
  REALTIME
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  ON_DEMAND
  ONE_TIME
}

// ============================================
// LES 12 DOMAINES ÉTHIQUES
// ============================================

enum EthicalDomain {
  // Cercle 1 : Les Personnes (6)
  PRIVACY           // Vie privée
  EQUITY            // Équité
  TRANSPARENCY      // Transparence
  AUTONOMY          // Autonomie
  SECURITY          // Sécurité
  RECOURSE          // Recours

  // Cercle 2 : L'Organisation (3)
  MASTERY           // Maîtrise
  RESPONSIBILITY    // Responsabilité
  SOVEREIGNTY       // Souveraineté

  // Cercle 3 : La Société (3)
  SUSTAINABILITY    // Durabilité
  LOYALTY           // Loyauté
  SOCIETAL_BALANCE  // Équilibre sociétal
}

// ============================================
// NOEUDS (Blocs du graphe)
// ============================================
// IMPORTANT : Les données ne sont PAS dans les nœuds, uniquement dans les flux

model Node {
  id     String   @id @default(cuid())
  siaId  String
  sia    Sia      @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Identité
  type    NodeType
  subtype String?
  label   String

  // Position React Flow
  positionX  Float  @default(0)
  positionY  Float  @default(0)

  // Style personnalisé (React Flow)
  style     Json?

  // Annotation des domaines (aide le moteur de détection)
  reinforcesDomains EthicalDomain[]  // Ce bloc renforce ces domaines
  affectsDomains    EthicalDomain[]  // Ce bloc peut affecter ces domaines

  // Attributs spécifiques au type (JSON flexible)
  // Voir documentation ci-dessous
  attributes Json @default("{}")

  // Relations
  outgoingEdges Edge[] @relation("EdgeSource")
  incomingEdges Edge[] @relation("EdgeTarget")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
}

// DOCUMENTATION DES ATTRIBUTS PAR TYPE DE NŒUD :
//
// Pour HUMAN:
// {
//   humanType: "user" | "operator" | "supervisor" | "affected_third_party",
//   vulnerability: "none" | "minor" | "significant" | "high",
//   expertise: "low" | "medium" | "high",
//   hasConsented: boolean,
//   canAppeal: boolean,
//   decisionPower: "none" | "advisory" | "blocking" | "final"
// }
//
// Pour AI:
// {
//   modelType: "rules" | "ml_classic" | "deep_learning" | "llm",
//   autonomyLevel: "informative" | "suggestive" | "decisive" | "autonomous",
//   hasExplainability: boolean,
//   hasBiasTesting: boolean,
//
//   // ATTRIBUTS DE DÉPENDANCE (si externe)
//   isExternal: boolean,
//   provider: string | null,           // "OpenAI", "Anthropic", "Google", "Microsoft"
//   modelName: string | null,          // "GPT-4", "Claude 3.5"
//   isOpaque: boolean,                 // Fonctionnement interne inconnu
//   canTrainOnYourData: boolean,       // Fournisseur utilise vos données
//   hasFallback: boolean,
//   fallbackDescription: string | null
// }
//
// Pour INFRA:
// {
//   infraType: "database" | "api" | "storage" | "interface" | "data_lake",
//   hasEncryption: boolean,
//   retentionPolicy: "minimal" | "standard" | "long" | "indefinite",
//
//   // ATTRIBUTS DE DÉPENDANCE (si externe)
//   isExternal: boolean,
//   provider: string | null,           // "AWS", "Azure", "GCP", "OVH"
//   location: "EU" | "US" | "OTHER" | "UNKNOWN",
//   hasFallback: boolean,
//   fallbackDescription: string | null,
//   slaLevel: string | null,           // "99.9%", "99%"
//   canModifyWithoutNotice: boolean
// }
//
// Pour ORG:
// {
//   orgType: "deployer" | "subcontractor" | "regulator" | "data_controller",
//   jurisdiction: string,
//   responsibilities: string[]
// }

enum NodeType {
  HUMAN
  AI
  INFRA
  ORG
}

// ============================================
// FLUX (Liens entre blocs)
// ============================================
// IMPORTANT : C'est ICI que sont définies les données transportées

model Edge {
  id       String @id @default(cuid())
  siaId    String
  sia      Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Connexion
  sourceId String
  source   Node   @relation("EdgeSource", fields: [sourceId], references: [id], onDelete: Cascade)
  targetId String
  target   Node   @relation("EdgeTarget", fields: [targetId], references: [id], onDelete: Cascade)

  // Nom du flux
  label    String?

  // Direction (qui initie)
  direction FlowDirection

  // Nature technique du flux
  nature    FlowNature

  // NOUVEAU : Intention du flux (pourquoi ce flux existe)
  intent    FlowIntent?

  // NOUVEAU : Canal technique
  channel   FlowChannel @default(API)

  // === DONNÉES TRANSPORTÉES (unique endroit où c'est défini) ===
  dataCategories String[]
  sensitivity    Sensitivity     @default(STANDARD)

  // Niveau d'automatisation
  automation     AutomationLevel @default(INFORMATIVE)

  // NOUVEAU : Réversibilité de la décision
  isReversible   Boolean         @default(true)

  // Criticité du flux
  criticality    FlowCriticality @default(IMPORTANT)

  // === PROFIL ÉTHIQUE (5 dimensions 1-5) ===
  agentivity     Float?   // Niveau d'agentivité
  asymmetry      Float?   // Asymétrie informationnelle
  irreversibility Float?  // Irréversibilité
  scalability    Float?   // Scalabilité
  opacity        Float?   // Opacité

  // Métadonnées
  frequency      Frequency       @default(ON_DEMAND)
  legalBasis     LegalBasis?

  // Relations
  tensionEdges   TensionEdge[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
  @@index([sourceId])
  @@index([targetId])
}

enum FlowDirection {
  H2M   // Humain vers Machine
  M2M   // Machine vers Machine
  M2H   // Machine vers Humain
  H2H   // Humain vers Humain (via machine)
}

enum FlowNature {
  COLLECTION      // Collecte de données
  STORAGE         // Stockage
  PROCESSING      // Traitement général
  INFERENCE       // Traitement/inférence
  DECISION        // Prise de décision
  SCORING         // Notation/scoring
  RECOMMENDATION  // Recommandation
  PERSONALIZATION // Personnalisation
  NOTIFICATION    // Notification/affichage
  TRANSFER        // Transfert simple
  MONITORING      // Surveillance
  MODERATION      // Modération de contenu
  PREDICTION      // Prédiction
  RISK_SCORING    // Score de risque
  PROFILING       // Profilage
  LEARNING        // Apprentissage
  CONTROL         // Contrôle/supervision
  ENRICHMENT      // Enrichissement de données
}

// NOUVEAU : Intention du flux
enum FlowIntent {
  COMMAND         // Ordre d'action
  FEEDBACK        // Retour/évaluation
  SURVEILLANCE    // Monitoring/contrôle
  INFORMATION     // Notification/affichage
  EVALUATION      // Scoring/classement
  TRAINING        // Données d'apprentissage
  QUERY           // Requête/interrogation
}

// NOUVEAU : Canal technique
enum FlowChannel {
  API             // Appel API
  USER_INTERFACE  // Interface utilisateur
  SENSOR          // Capteur/IoT
  NOTIFICATION    // Push/email/SMS
  BATCH_PROCESS   // Traitement batch
  WEBHOOK         // Webhook
  FILE_TRANSFER   // Transfert de fichier
}

enum DataCategory {
  IDENTIFIER        // Nom, email, téléphone
  DEMOGRAPHIC       // Âge, genre, nationalité
  LOCATION          // Adresse, GPS
  FINANCIAL         // Revenus, transactions
  HEALTH            // Données de santé
  BIOMETRIC         // Empreintes, visage
  BEHAVIORAL        // Historique, navigation
  PROFESSIONAL      // CV, performance
  OPINION           // Opinions politiques/religieuses
  JUDICIAL          // Casier, litiges
  INFERRED          // Données déduites
  CONTENT           // Contenu utilisateur
  TECHNICAL         // Logs, métadonnées
  OTHER
}

enum Sensitivity {
  STANDARD
  SENSITIVE          // Art. 9 RGPD
  HIGHLY_SENSITIVE   // Santé, biométrie, judiciaire
}

enum AutomationLevel {
  INFORMATIVE           // Information pure
  ASSISTED              // Aide à la décision
  SEMI_AUTO             // Décision avec validation humaine
  AUTO_WITH_RECOURSE    // Auto mais contestable
  AUTO_NO_RECOURSE      // Auto sans recours
}

enum FlowCriticality {
  ACCESSORY    // Le système peut fonctionner sans
  IMPORTANT    // Dégrade le service si absent
  CRITICAL     // Le système ne peut pas fonctionner sans
}

enum LegalBasis {
  CONSENT
  CONTRACT
  LEGAL_OBLIGATION
  VITAL_INTEREST
  PUBLIC_INTEREST
  LEGITIMATE_INTEREST
}

// ============================================
// TENSIONS ÉTHIQUES
// ============================================

model Tension {
  id     String @id @default(cuid())
  siaId  String
  sia    Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Pattern de tension (ex: PRIVACY_VS_TRANSPARENCY)
  pattern       String
  description   String    @db.Text
  status        TensionStatus @default(DETECTED)
  level         TensionLevel  @default(INDIVIDUAL)

  // Domaines impactés
  impactedDomains String[]

  // Scoring
  severity        Float?     // Sévérité de base (1-5)
  exposureScore   Float?     // Score d'exposition calculé
  residualScore   Float?     // Score résiduel après actions

  // Détection
  triggeredByRule   String?    // Règle qui a détecté cette tension
  detectionReason   String?    @db.Text

  // Facteurs
  activeAmplifiers  String[]
  activeMitigators  String[]

  // Traçabilité vers le graphe
  relatedNodeIds    String[]

  // Relations
  tensionEdges      TensionEdge[]
  arbitration       Arbitration?
  actions           Action[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
  @@index([pattern])
  @@index([status])
}

model TensionEdge {
  id        String  @id @default(cuid())
  tensionId String
  tension   Tension @relation(fields: [tensionId], references: [id], onDelete: Cascade)
  edgeId    String
  edge      Edge    @relation(fields: [edgeId], references: [id], onDelete: Cascade)

  @@unique([tensionId, edgeId])
  @@index([tensionId])
  @@index([edgeId])
}

enum TensionStatus {
  DETECTED
  VALIDATED
  CONTESTED
  ARBITRATED
  IN_PROGRESS
  RESOLVED
  DISMISSED
}

enum TensionLevel {
  INDIVIDUAL
  RELATIONAL
  SYSTEMIC
}

enum RuleFamily {
  STRUCTURAL    // S - Analyse de la forme du graphe
  DATA          // D - Analyse des flux de données
  DEPENDENCY    // E - Analyse des composants externes
  CONTEXTUAL    // C - Selon le secteur d'application
  GOVERNANCE    // G - Organisation autour du système
}

// ============================================
// ARBITRAGE (4 questions + score de maturité)
// ============================================

model Arbitration {
  id        String  @id @default(cuid())
  tensionId String  @unique
  tension   Tension @relation(fields: [tensionId], references: [id], onDelete: Cascade)

  // Décision prise
  decision          String
  justification     String    @db.Text

  // Mesures sélectionnées
  selectedMeasures  String[]

  // Analyse complémentaire
  benefitAnalysis   String?   @db.Text
  riskAcceptance    String?   @db.Text
  rejectionReason   String?   @db.Text

  // Proportionnalité et contestabilité
  proportionality   String?   @db.Text
  contestability    String?   @db.Text

  // Révision
  revisionConditions    String?   @db.Text
  compensatoryMeasures  String?   @db.Text
  nextReviewDate        DateTime?

  // NOUVEAU : Score de maturité (0-4)
  maturityLevel ArbitrationMaturity @default(RECOGNIZED)

  // Documentation des désaccords
  hasDisagreement        Boolean              @default(false)
  divergentPositions     DivergentPosition[]
  finalDecisionAuthority String?

  // Métadonnées
  arbitratedById String?
  arbitratedBy   User?    @relation(fields: [arbitratedById], references: [id])
  arbitratedAt   DateTime @default(now())

  validatedById  String?
  validatedAt    DateTime?

  // Évidences fournies (pour niveau 3+)
  evidences Evidence[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Score de maturité de l'arbitrage
enum ArbitrationMaturity {
  NOT_TREATED   // 0 - Tension non reconnue
  RECOGNIZED    // 1 - Reconnue mais options non analysées
  DECIDED       // 2 - Trade-off explicite mais sans preuves
  TESTED        // 3 - Preuves (tests, red-team, audits)
  MONITORED     // 4 - KPIs + alerting + recours + revue
}

model DivergentPosition {
  id            String @id @default(cuid())
  arbitrationId String
  arbitration   Arbitration @relation(fields: [arbitrationId], references: [id], onDelete: Cascade)

  stakeholder String
  role        String
  position    String  @db.Text

  createdAt DateTime @default(now())
}

// ============================================
// ACTIONS
// ============================================

model Action {
  id    String @id @default(cuid())
  siaId String
  sia   Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  // Liens
  dilemmaId     String?
  dilemma       Tension?     @relation(fields: [dilemmaId], references: [id], onDelete: SetNull)

  // Contenu
  title       String
  description String?  @db.Text

  // Type d'action selon la méthodologie
  actionType ActionType @default(MITIGATION)
  category   ActionCategory

  // Domaine cible
  targetDomain   EthicalDomain?
  expectedImpact Int?  // -2 à +2
  estimatedImpact Json?  // Impact estimé par domaine

  // Priorisation
  priority Priority @default(MEDIUM)
  effort   Effort   @default(MEDIUM)
  status   ActionStatus @default(TODO)

  // Traçabilité
  templateId  String?
  sourceRule  String?

  // Checklist intégrée
  checklist   Json?

  // Dates
  dueDate     DateTime?
  completedAt DateTime?

  // Assignation
  assigneeId String?
  assignee   User?   @relation(fields: [assigneeId], references: [id])

  // Preuves
  evidences Evidence[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siaId])
  @@index([dilemmaId])
  @@index([status])
}

enum ActionType {
  MITIGATION    // Réduire l'intensité de la tension
  COMPENSATION  // Contrebalancer le pôle minoré
  SURVEILLANCE  // Monitorer l'évolution
}

enum ActionCategory {
  MINIMIZATION
  TRANSPARENCY
  HUMAN_CONTROL
  RECOURSE
  TECHNICAL
  ORGANIZATIONAL
  DESIGN
  CONTRACTUAL
  DOCUMENTATION
}

enum Priority {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum Effort {
  TRIVIAL
  SMALL
  MEDIUM
  LARGE
  HUGE
}

enum ActionStatus {
  TODO
  IN_PROGRESS
  BLOCKED
  DONE
  CANCELLED
}

// ============================================
// PREUVES (pour maturité niveau 3+)
// ============================================

model Evidence {
  id       String @id @default(cuid())

  // Peut être liée à une action OU un arbitrage
  actionId      String?
  action        Action?      @relation(fields: [actionId], references: [id], onDelete: Cascade)
  arbitrationId String?
  arbitration   Arbitration? @relation(fields: [arbitrationId], references: [id], onDelete: Cascade)

  type     EvidenceType
  title    String
  description String?
  url      String?
  fileKey  String?
  fileName String?

  uploadedAt DateTime @default(now())
}

enum EvidenceType {
  DOCUMENT
  SCREENSHOT
  LINK
  CODE
  TEST_RESULT
  AUDIT_REPORT
  METRIC_DASHBOARD
  PROCEDURE
  OTHER
}

// ============================================
// VERSIONING
// ============================================

model Version {
  id        String @id @default(cuid())
  siaId     String
  sia       Sia    @relation(fields: [siaId], references: [id], onDelete: Cascade)

  number    Int
  label     String?
  snapshot  Json
  changelog String?  @db.Text

  createdById String
  createdAt   DateTime @default(now())

  @@unique([siaId, number])
  @@index([siaId])
}
